---
title: "Is the friend of my friend my enemy?"
    
title-slide-attributes:
  data-background-image: /Users/Gabe/Desktop/title_slide.jpg
  data-background-size: cover
  data-background-opacity: "0.5"
#subtitle: "The maintenance of multiple hosts and symbionts in a mutualism network."
author:
  name: "Gabe Runte, Holly Moeller"
  affiliation: University of California, Santa Barbara
format: 
  revealjs:
    embed-resources: true
    slide-number: true
    # menu: false
    preview-links: auto
    theme: serif
    footer: "gaberunte.com"
  # pptx:
  #   reference-doc: template_gr_esa2023.pptx
---

```{r, echo = FALSE, warning = F, message=FALSE}
library(tidyverse)
library(here)
library(png)
library(kableExtra)
library(ggforce)
library(gganimate)
library(patchwork)

b.color = "#85A389"
n.color = "#A2CDB0"
f.color = "#F1C27B"
beige = "#F0F1EA"

#drawings
fir = readPNG(here("esa", "images", "firsmall.png"))
oak = readPNG(here("esa", "images", "oaksmall.png"))
amanita = readPNG(here("esa", "images", "amanitasmall.png"))
suillus = readPNG(here("esa", "images", "suillussmall.png"))

tp_bg = theme(
         panel.background = element_rect(fill='transparent'),
         plot.background = element_rect(fill=beige, color=beige),
         panel.grid.major = element_blank(),
         panel.grid.minor = element_blank()
       )
```

# Situating a model {background-color="black" background-image="images/pollination.jpg" background-opacity=0.5} 

## On Mutualism {background-color="black" background-image="images/pollination.jpg" background-opacity=0.5 auto-animate=true} 

:::{.fragment }
::: {style="margin-top: 0px; font-size: 1.15em; color: white;"}
Theory predicts that cooperation is evolutionarily unstable in the absence of mechanisms that counteract the selective incentive to cheat <br> - M.E. Fredrickson
:::

:::




## The mycorrhizal symbiosis {background-color="black" background-image="images/myco_root.jpeg" background-opacity=0.75 auto-animate=true} 

<br><br>

::: {.fragment .fade-in}
Partner preference
:::

<br><br><br><br><br>

::: {style="margin-top: 0px; font-size: 0.8em; color: #c7c9c8;"}
Theory predicts that cooperation is evolutionarily unstable in the absence of mechanisms that counteract the selective incentive to cheat <br> - M.E. Fredrickson
:::

## Partner preference {background-color="white" background-image="images/myco_root.jpeg" background-opacity=0.25 auto-animate=true}
::: columns
::: {.column width="55%"}

<br>

:::{.fragment}
Evolutionary influence
:::

<br>

:::{.fragment}
Inherent affinity
:::
:::{.fragment}
<span style="font-size:0.6em;">Not based in partner quality</span>
:::


:::
::: {.column width="45%"}

<br>

:::{.fragment }

![](images/cheesehead.jpg)
:::
:::
:::



## The mycorrhizal symbiosis {background-color="black" background-image="images/myco_root.jpeg" background-opacity=0.75 auto-animate=true} 

<br><br>

<span style="color:#c7c9c8;">Partner preference</span>

<br>

:::{.fragment .fade-in}
Quality assessment (ROI)
:::

<br><br>

::: {style="margin-top: 0px; font-size: 0.8em; color: #c7c9c8;"}
Theory predicts that cooperation is evolutionarily unstable in the absence of mechanisms that counteract the selective incentive to cheat <br> - M.E. Fredrickson
:::


## Return on Investment {background-color="white" background-image="images/myco_root.jpeg" background-opacity=0.25 auto-animate=true}

::: columns
::: {.column width="55%"}

<br>

:::{.fragment fragment-index=1}
Optimal Investment Strategy
:::

<br>

:::{.fragment fragment-index=3}
Evidence in emperical work 
:::

:::{.fragment fragment-index=4}
<span style="font-size:0.6em;">Kiers et al. 2011</span><br>
<span style="font-size:0.6em;">Fellbaum et al. 2014</span><br>
<span style="font-size:0.6em;">Bogar et al. 2019</span>

:::

:::

::: {.column width="45%"}
::: {.fragment fragment-index=2}
![](images/investor.jpeg)
:::

:::
:::

## The mycorrhizal symbiosis {background-color="black" background-image="images/myco_root.jpeg" background-opacity=0.75 auto-animate=true} 

<br><br>

Partner preference

<br>

Quality assessment (ROI)


<br><br>

::: {style="margin-top: 0px; font-size: 0.8em; color: #c7c9c8;"}
Theory predicts that cooperation is evolutionarily unstable in the absence of mechanisms that counteract the selective incentive to cheat <br> - M.E. Fredrickson
:::



<!-- End of introduction section, begin model description-->


# Building a model {background-color="black" background-image="images/model_tree.jpeg" background-opacity=0.65 auto-animate=true}
## A simple model 
![](diagrams/1t1f_both.PNG){.absolute top=80 right=0}

## A simple model 
![](diagrams/1t1f_nutes.PNG){.absolute top=80 right=0}

## A simple model 
![](diagrams/1t1f_carbon.PNG){.absolute top=80 right=0}

## A simple model 
![](diagrams/1t1f_all.PNG){.absolute top=80 right=0}


## A simple model 

::: columns
::: {.column width="35%"}
![](diagrams/crops/1t1f_all.PNG)

:::
::: {.column width="65%"}
```{r, eval = F}
#parameter values 
# See two tree two fungus section for a full annotation of what each parameter refers to!
tset = seq(from = 0, to = 100, by = 0.01)
a <- 0.25
p1 <- .8
mB1 <- .15
mN1 <- 5
epsilon <- 0.15
mF1 <- 0.1
u1 <- .25
N0 <- 100

#holding vectors and initial conditions
b1.set = rep(NaN, length(tset)); b1.set[1] <- 65
n1.set = rep(NaN, length(tset)); n1.set[1] <- b1.set[1]*0.5
f1.set = rep(NaN, length(tset)); f1.set[1] <- b1.set[1]*0.15
e.set = rep(NaN, length(tset));  e.set[1]  <- 100 - n1.set[1]

for(i in 2:length(tset)){
  dt <- tset[i]-tset[i-1]
  B1 <- b1.set[i-1];  N1 <- n1.set[i-1]; F1 <- f1.set[i-1]; E <- e.set[i-1]

  dB1 <- (p1*N1 - (a+mB1)*B1)*dt
  dN1 <- (E*(u1*F1) - mN1*N1)*dt
  dF1 <- ((a*B1)*epsilon - mF1*F1)*dt

  
b1.set[i] <- B1 + dB1;n1.set[i] <- N1 + dN1;f1.set[i] <- F1 + dF1;e.set[i] <- E - (dN1)}

sim.1t1f = tibble(time = tset) %>% 
  mutate(b1 = b1.set)%>% 
  mutate(n1 = n1.set)%>% 
  mutate(f1 = f1.set)%>% 
  mutate(e = e.set)  

long.1t1f = sim.1t1f %>% 
  select(time:f1) %>% 
  pivot_longer(cols = b1:f1, names_to = "pool", values_to = 'size') %>% 
  mutate(rep = str_sub(pool, 2,2)) %>% 
  mutate(pool = str_sub(pool, 1,1)) %>%
  group_by(pool, rep) %>% 
 slice(which(row_number() %% 51 == 1)) 

short.1t1f = sim.1t1f %>% 
  select(time:f1) %>% 
  pivot_longer(cols = b1:f1, names_to = "pool", values_to = 'size') %>% 
  mutate(rep = str_sub(pool, 2,2)) %>% 
  mutate(pool = str_sub(pool, 1,1)) %>%
  filter(time <= 75)

plot.1t1f = 
  ggplot(short.1t1f, aes(x = time, y = size, color = pool))+
  geom_line(aes(linetype = rep), size = 2)+
  labs(x = "Time (yrs)", y = "Pool Size")+
  scale_color_manual(name = "", breaks = c("b", "n", "f"), labels = c("Host biomass", "Host nitrogen", "Fungal biomass"), values = c(b.color, n.color, f.color))+
  theme_classic()+guides(linetype = "none")+theme_minimal()+ guides(alpha =  FALSE)+ tp_bg +transition_reveal(time)

  animate(plot.1t1f, duration = 5, renderer = gifski_renderer(loop = FALSE), 
          height = 5, width = 7, units = "in", res = 300)
 anim_save(here("esa", "figures", "savegif.gif"))

```
:::{.fragment}
![](figures/savegif.gif)
:::

:::

:::

## A simple model 
![](diagrams/1t1f_arrows.PNG){.absolute top=80 right=210}

## A (less) simple model 
![](diagrams/2t2f_separate_nonit.PNG){.absolute top=80 right=210}

## A (less) simple model 
![](diagrams/2t2f_separate.PNG){.absolute top=80 right=210}

## A mutualism network model 
![](diagrams/2t2f_treessplit.PNG){.absolute top=80 right=210}

## A mutualism network model 
![](diagrams/2t2f_all.PNG){.absolute top=80 right=210}

## A mutualism network model 
![](diagrams/2t2f_arrows.PNG){.absolute top=80 right=210}

## A mutualism network model 
![](diagrams/2t2f_arrows_thin.PNG){.absolute top=80 right=210}

## Varying partner preference

![](diagrams/2t2f_arrows.PNG){.absolute bottom=-80 left=50 width="350"}
![](diagrams/2t2f_arrows_thin.PNG){.absolute bottom=-80 right=50 width="350"}

::: columns
::: {.column width="50%"}

```{r, echo = FALSE}
st.pts = seq(10,30, length.out = 10)

for(j in 1:length(st.pts)){

primary.weight = 0.5 # how much preference each member of the network has for it's primary partner (e.g. Fungus 2's preference for Host 2)
#parameter values
tset = seq(from = 0, to = 100, by = 0.1) # a timeseries to iterate over
a <- 0.25 # host allocation to symbiont
p1 <- 0.5#(sin((2*pi/1000)*tset) + 1) / 2 # host 1 photosynthetic rate
p2 <- 0.5#1-(sin((2*pi/1000)*tset) + 1) / 2 # host 2 photosynthetic rate
mB1 <- .15 # host 1 mortality
mB2 <- .15 # host 2 mortality
mN1 <- mB1 # host 1 nitrogen loss rate
mN2 <- mB2 # host 2 nitrogen loss rate
r11 <- primary.weight # preference of host 1 toward fungus 1
r12 <- 1-r11 # preference of host 1 toward fungus 2
r22 <- primary.weight # preference of host 2 toward fungus 2
r21 <- 1-r22 # preference of host 2 toward fungus 1
epsilon <- 0.15 # fungal conversion efficiency
mF1 <- 0.1 # fungus 1 mortality rate
mF2 <- mF1 # fungus 2 mortality rate
u1 <- .25 # fungus 1 uptake rate
u2 <- .25 # fungus 2 uptake rate
s11 <- primary.weight # preference of fungus 1 toward host 1
s12 <- 1-s11 # preference of fungus 1 toward host 2
s22 <- primary.weight # preference of fungus 2 toward host 2
s21 <- 1-s22 # preference of fungus 2 toward host 1
N0 <- 100 # total system nitrogen
l.h = 1 # percent of tree resources lost from ROI allocation
l.s = 1 # percent of fungal resources lost from ROI allocation


#holding vectors and initial conditions
b1.set = rep(NaN, length(tset)); b1.set[1] <- 50
b2.set = rep(NaN, length(tset)); b2.set[1] <- st.pts[j]
n1.set = rep(NaN, length(tset)); n1.set[1] <- b1.set[1]*0.5
n2.set = rep(NaN, length(tset)); n2.set[1] <- b2.set[1]*0.5
f1.set = rep(NaN, length(tset)); f1.set[1] <- b1.set[1]*0.15
f2.set = rep(NaN, length(tset)); f2.set[1] <- b2.set[1]*0.15
e.set = rep(NaN, length(tset));  e.set[1]  <- 100 - n1.set[1]-n2.set[1]

#historical sharing percentages based on relative size of each 
c1f1.set = rep(NaN, length(tset)); c1f1.set[1] <- f1.set[1]/(f1.set[1]+f2.set[1])
c1f2.set = rep(NaN, length(tset)); c1f2.set[1] <- f2.set[1]/(f1.set[1]+f2.set[1])
c2f1.set = rep(NaN, length(tset)); c2f1.set[1] <- f1.set[1]/(f1.set[1]+f2.set[1])
c2f2.set = rep(NaN, length(tset)); c2f2.set[1] <- f2.set[1]/(f1.set[1]+f2.set[1])
f1n1.set = rep(NaN, length(tset)); f1n1.set[1] <- b1.set[1]/(b1.set[1]+b2.set[1])
f1n2.set = rep(NaN, length(tset)); f1n2.set[1] <- b2.set[1]/(b1.set[1]+b2.set[1])
f2n1.set = rep(NaN, length(tset)); f2n1.set[1] <- b1.set[1]/(b1.set[1]+b2.set[1])
f2n2.set = rep(NaN, length(tset)); f2n2.set[1] <- b2.set[1]/(b1.set[1]+b2.set[1])


for(i in 2:length(tset)){
  dt <- tset[i]-tset[i-1]
  B1 <- b1.set[i-1];  N1 <- n1.set[i-1]; F1 <- f1.set[i-1]
  B2 <- b2.set[i-1];  N2 <- n2.set[i-1];F2 <- f2.set[i-1]; E <- e.set[i-1]
  c1tof1 <- c1f1.set[i-1]; c1tof2 <- c1f2.set[i-1]; c2tof1 <- c2f1.set[i-1]; c2tof2 <- c2f2.set[i-1]
  f1ton1 <- f1n1.set[i-1]; f1ton2 <- f1n2.set[i-1]; f2ton1 <- f2n1.set[i-1]; f2ton2 <- f2n2.set[i-1]

  dB1 <- (p1 * N1 - (a + mB1)*B1)*dt
  dN1 <- (E*(u1*(F1*f1ton1*(1-l.s)+F1*s11*l.s)+u2*(F2*f2ton1*(1-l.s)+F2*s21*l.s))-mN1*N1)*dt
  dB2 <- (p2 * N2 - (a + mB2)*B2)*dt
  dN2 <- (E*(u1*F1*f1ton2*(1-l.s)+u1*F1*s12*l.s+u2*F2*f2ton2*(1-l.s)+u2*F2*s22*l.s)-mN2*N2)*dt
  dF1 <- ((a*B1*c1tof1*(1-l.h)+l.h*a*B1*r11)*epsilon+(a*B2*c2tof1*(1-l.h)+l.h*a*B2*r21)*epsilon-mF1*F1)*dt
  dF2 <- ((a*B1*c1tof2*(1-l.h)+l.h*a*B1*r12)*epsilon+(a*B2*c2tof2*(1-l.h)+l.h*a*B2*r22)*epsilon-mF2*F2)*dt

c1tof1.new <- r11*u1*(F1*f1ton1*(1-l.s)+F1*s11*l.s)/(r11*u1*(F1*f1ton1*(1-l.s)+F1*s11*l.s)+r12*u2*(F2*f2ton1*(1-l.s)+F2*s21*l.s))
c1tof2.new <- r12*u2*(F2*f2ton1*(1-l.s)+F2*s21*l.s)/(r11*u1*(F1*f1ton1*(1-l.s)+F1*s11*l.s)+r12*u2*(F2*f2ton1*(1-l.s)+F2*s21*l.s))
c2tof1.new <- r21*u1*(F1*f1ton2*(1-l.s)+F1*s12*l.s)/(r21*u1*(F1*f1ton2*(1-l.s)+F1*s12*l.s)+r22*u2*(F2*f2ton2*(1-l.s)+F2*s22*l.s))
c2tof2.new <- r22*u2*(F2*f2ton2*(1-l.s)+F2*s22*l.s)/(r21*u1*(F1*f1ton2*(1-l.s)+F1*s12*l.s)+r22*u2*(F2*f2ton2*(1-l.s)+F2*s22*l.s))
f1ton1.new <- s11*(a*B1*c1tof1*(1-l.h)+l.h*a*B1*r11)/(s11*(a*B1*c1tof1*(1-l.h)+l.h*a*B1*r11)+s12*(a*B2*c2tof1*(1-l.h)+l.h*a*B2*r21))
f1ton2.new <- s12*(a*B2*c2tof1*(1-l.h)+l.h*a*B2*r21)/(s11*(a*B1*c1tof1*(1-l.h)+l.h*a*B1*r11)+s12*(a*B2*c2tof1*(1-l.h)+l.h*a*B2*r21))
f2ton1.new <- s21*(a*B1*c1tof2*(1-l.h)+l.h*a*B1*r12)/(s21*(a*B1*c1tof2*(1-l.h)+l.h*a*B1*r12)+s22*(a*B2*c2tof2*(1-l.h)+l.h*a*B2*r22))
f2ton2.new <- s22*(a*B2*c2tof2*(1-l.h)+l.h*a*B2*r22)/(s21*(a*B1*c1tof2*(1-l.h)+l.h*a*B1*r12)+s22*(a*B2*c2tof2*(1-l.h)+l.h*a*B2*r22))

b1.set[i] <- B1 + dB1;n1.set[i] <- N1 + dN1;f1.set[i] <- F1 + dF1
b2.set[i] <- B2 + dB2;n2.set[i] <- N2 + dN2;f2.set[i] <- F2 + dF2;e.set[i] <- E - (dN1 + dN2)
  
c1f1.set[i]<- c1tof1.new;c1f2.set[i]<- c1tof2.new;c2f1.set[i]<- c2tof1.new;c2f2.set[i]<- c2tof2.new
f1n1.set[i]<- f1ton1.new;f1n2.set[i]<- f1ton2.new;f2n1.set[i]<- f2ton1.new;f2n2.set[i]<- f2ton2.new
}

if(j == 1)
{total.2t2f = tibble(time = tset) %>% 
  mutate(b1 = b1.set)%>% 
  mutate(b2 = b2.set)%>% 
  mutate(n1 = n1.set)%>% 
  mutate(n2 = n2.set) %>% 
  mutate(f1 = f1.set)%>% 
  mutate(f2 = f2.set) %>% 
  mutate(st.pt = b2.set[1])}
if(j>1)
{loop.df = tibble(time = tset) %>% 
  mutate(b1 = b1.set)%>% 
  mutate(b2 = b2.set)%>% 
  mutate(n1 = n1.set)%>% 
  mutate(n2 = n2.set) %>% 
  mutate(f1 = f1.set)%>% 
  mutate(f2 = f2.set) %>% 
  mutate(st.pt = b2.set[1])
  total.2t2f = total.2t2f %>% 
    bind_rows(loop.df)}
}
long.2t2f = total.2t2f %>% 
  pivot_longer(cols = b1:f2, names_to = "pool", values_to = 'size') %>% 
  mutate(plot.group = paste0(pool, st.pt)) %>% 
  group_by(plot.group) %>% 
  mutate(pool_short = str_sub(pool, 1,1))


stableplot = ggplot(long.2t2f %>% 
         filter(pool_short != "n"), aes(x = time, y = size, color = pool_short, group = plot.group))+geom_line(alpha = 0.5, size = 1.5)+
  scale_color_manual(name = "", breaks = c("b", "n", "f"), labels = c("Host biomass", "Host nitrogen", "Fungal biomass"), values = c(b.color, n.color, f.color))+
  labs(x = "Time (yrs)", y = "Pool sizes")+theme_minimal()+ guides(alpha =  FALSE)+ tp_bg+theme(legend.box = "horizontal", legend.position = c(0.8, 0.15))

ggsave(plot = stableplot, filename = here('esa/figures/stableplot.png'), width = 7/1.5, height = 5/1.5)

```
:::{.fragment fragment-index=1}
![](figures/stableplot.png)
:::

:::

::: {.column width="50%"}
```{r, echo = FALSE}
st.pts = seq(10,30, length.out = 10)

for(j in 1:length(st.pts)){

primary.weight = 0.95 # how much preference each member of the network has for it's primary partner (e.g. Fungus 2's preference for Host 2)
#parameter values
tset = seq(from = 0, to = 100, by = 0.1) # a timeseries to iterate over
a <- 0.25 # host allocation to symbiont
p1 <- 0.5#(sin((2*pi/1000)*tset) + 1) / 2 # host 1 photosynthetic rate
p2 <- 0.5#1-(sin((2*pi/1000)*tset) + 1) / 2 # host 2 photosynthetic rate
mB1 <- .15 # host 1 mortality
mB2 <- .15 # host 2 mortality
mN1 <- mB1 # host 1 nitrogen loss rate
mN2 <- mB2 # host 2 nitrogen loss rate
r11 <- primary.weight # preference of host 1 toward fungus 1
r12 <- 1-r11 # preference of host 1 toward fungus 2
r22 <- primary.weight # preference of host 2 toward fungus 2
r21 <- 1-r22 # preference of host 2 toward fungus 1
epsilon <- 0.15 # fungal conversion efficiency
mF1 <- 0.1 # fungus 1 mortality rate
mF2 <- mF1 # fungus 2 mortality rate
u1 <- .25 # fungus 1 uptake rate
u2 <- .25 # fungus 2 uptake rate
s11 <- primary.weight # preference of fungus 1 toward host 1
s12 <- 1-s11 # preference of fungus 1 toward host 2
s22 <- primary.weight # preference of fungus 2 toward host 2
s21 <- 1-s22 # preference of fungus 2 toward host 1
N0 <- 100 # total system nitrogen
l.h = 1 # percent of tree resources lost from ROI allocation
l.s = 1 # percent of fungal resources lost from ROI allocation


#holding vectors and initial conditions
b1.set = rep(NaN, length(tset)); b1.set[1] <- 50
b2.set = rep(NaN, length(tset)); b2.set[1] <- st.pts[j]
n1.set = rep(NaN, length(tset)); n1.set[1] <- b1.set[1]*0.5
n2.set = rep(NaN, length(tset)); n2.set[1] <- b2.set[1]*0.5
f1.set = rep(NaN, length(tset)); f1.set[1] <- b1.set[1]*0.15
f2.set = rep(NaN, length(tset)); f2.set[1] <- b2.set[1]*0.15
e.set = rep(NaN, length(tset));  e.set[1]  <- 100 - n1.set[1]-n2.set[1]

#historical sharing percentages based on relative size of each 
c1f1.set = rep(NaN, length(tset)); c1f1.set[1] <- f1.set[1]/(f1.set[1]+f2.set[1])
c1f2.set = rep(NaN, length(tset)); c1f2.set[1] <- f2.set[1]/(f1.set[1]+f2.set[1])
c2f1.set = rep(NaN, length(tset)); c2f1.set[1] <- f1.set[1]/(f1.set[1]+f2.set[1])
c2f2.set = rep(NaN, length(tset)); c2f2.set[1] <- f2.set[1]/(f1.set[1]+f2.set[1])
f1n1.set = rep(NaN, length(tset)); f1n1.set[1] <- b1.set[1]/(b1.set[1]+b2.set[1])
f1n2.set = rep(NaN, length(tset)); f1n2.set[1] <- b2.set[1]/(b1.set[1]+b2.set[1])
f2n1.set = rep(NaN, length(tset)); f2n1.set[1] <- b1.set[1]/(b1.set[1]+b2.set[1])
f2n2.set = rep(NaN, length(tset)); f2n2.set[1] <- b2.set[1]/(b1.set[1]+b2.set[1])


for(i in 2:length(tset)){
  dt <- tset[i]-tset[i-1]
  B1 <- b1.set[i-1];  N1 <- n1.set[i-1]; F1 <- f1.set[i-1]
  B2 <- b2.set[i-1];  N2 <- n2.set[i-1];F2 <- f2.set[i-1]; E <- e.set[i-1]
  c1tof1 <- c1f1.set[i-1]; c1tof2 <- c1f2.set[i-1]; c2tof1 <- c2f1.set[i-1]; c2tof2 <- c2f2.set[i-1]
  f1ton1 <- f1n1.set[i-1]; f1ton2 <- f1n2.set[i-1]; f2ton1 <- f2n1.set[i-1]; f2ton2 <- f2n2.set[i-1]

  dB1 <- (p1 * N1 - (a + mB1)*B1)*dt
  dN1 <- (E*(u1*(F1*f1ton1*(1-l.s)+F1*s11*l.s)+u2*(F2*f2ton1*(1-l.s)+F2*s21*l.s))-mN1*N1)*dt
  dB2 <- (p2 * N2 - (a + mB2)*B2)*dt
  dN2 <- (E*(u1*F1*f1ton2*(1-l.s)+u1*F1*s12*l.s+u2*F2*f2ton2*(1-l.s)+u2*F2*s22*l.s)-mN2*N2)*dt
  dF1 <- ((a*B1*c1tof1*(1-l.h)+l.h*a*B1*r11)*epsilon+(a*B2*c2tof1*(1-l.h)+l.h*a*B2*r21)*epsilon-mF1*F1)*dt
  dF2 <- ((a*B1*c1tof2*(1-l.h)+l.h*a*B1*r12)*epsilon+(a*B2*c2tof2*(1-l.h)+l.h*a*B2*r22)*epsilon-mF2*F2)*dt

c1tof1.new <- r11*u1*(F1*f1ton1*(1-l.s)+F1*s11*l.s)/(r11*u1*(F1*f1ton1*(1-l.s)+F1*s11*l.s)+r12*u2*(F2*f2ton1*(1-l.s)+F2*s21*l.s))
c1tof2.new <- r12*u2*(F2*f2ton1*(1-l.s)+F2*s21*l.s)/(r11*u1*(F1*f1ton1*(1-l.s)+F1*s11*l.s)+r12*u2*(F2*f2ton1*(1-l.s)+F2*s21*l.s))
c2tof1.new <- r21*u1*(F1*f1ton2*(1-l.s)+F1*s12*l.s)/(r21*u1*(F1*f1ton2*(1-l.s)+F1*s12*l.s)+r22*u2*(F2*f2ton2*(1-l.s)+F2*s22*l.s))
c2tof2.new <- r22*u2*(F2*f2ton2*(1-l.s)+F2*s22*l.s)/(r21*u1*(F1*f1ton2*(1-l.s)+F1*s12*l.s)+r22*u2*(F2*f2ton2*(1-l.s)+F2*s22*l.s))
f1ton1.new <- s11*(a*B1*c1tof1*(1-l.h)+l.h*a*B1*r11)/(s11*(a*B1*c1tof1*(1-l.h)+l.h*a*B1*r11)+s12*(a*B2*c2tof1*(1-l.h)+l.h*a*B2*r21))
f1ton2.new <- s12*(a*B2*c2tof1*(1-l.h)+l.h*a*B2*r21)/(s11*(a*B1*c1tof1*(1-l.h)+l.h*a*B1*r11)+s12*(a*B2*c2tof1*(1-l.h)+l.h*a*B2*r21))
f2ton1.new <- s21*(a*B1*c1tof2*(1-l.h)+l.h*a*B1*r12)/(s21*(a*B1*c1tof2*(1-l.h)+l.h*a*B1*r12)+s22*(a*B2*c2tof2*(1-l.h)+l.h*a*B2*r22))
f2ton2.new <- s22*(a*B2*c2tof2*(1-l.h)+l.h*a*B2*r22)/(s21*(a*B1*c1tof2*(1-l.h)+l.h*a*B1*r12)+s22*(a*B2*c2tof2*(1-l.h)+l.h*a*B2*r22))

b1.set[i] <- B1 + dB1;n1.set[i] <- N1 + dN1;f1.set[i] <- F1 + dF1
b2.set[i] <- B2 + dB2;n2.set[i] <- N2 + dN2;f2.set[i] <- F2 + dF2;e.set[i] <- E - (dN1 + dN2)
  
c1f1.set[i]<- c1tof1.new;c1f2.set[i]<- c1tof2.new;c2f1.set[i]<- c2tof1.new;c2f2.set[i]<- c2tof2.new
f1n1.set[i]<- f1ton1.new;f1n2.set[i]<- f1ton2.new;f2n1.set[i]<- f2ton1.new;f2n2.set[i]<- f2ton2.new
}

if(j == 1)
{total.2t2f = tibble(time = tset) %>% 
  mutate(b1 = b1.set)%>% 
  mutate(b2 = b2.set)%>% 
  mutate(n1 = n1.set)%>% 
  mutate(n2 = n2.set) %>% 
  mutate(f1 = f1.set)%>% 
  mutate(f2 = f2.set) %>% 
  mutate(st.pt = b2.set[1])}
if(j>1)
{loop.df = tibble(time = tset) %>% 
  mutate(b1 = b1.set)%>% 
  mutate(b2 = b2.set)%>% 
  mutate(n1 = n1.set)%>% 
  mutate(n2 = n2.set) %>% 
  mutate(f1 = f1.set)%>% 
  mutate(f2 = f2.set) %>% 
  mutate(st.pt = b2.set[1])
  total.2t2f = total.2t2f %>% 
    bind_rows(loop.df)}
}
long.2t2f = total.2t2f %>% 
  pivot_longer(cols = b1:f2, names_to = "pool", values_to = 'size') %>% 
  mutate(plot.group = paste0(pool, st.pt)) %>% 
  group_by(plot.group) %>% 
  mutate(pool_short = str_sub(pool, 1,1))


nearneutralplot = ggplot(long.2t2f %>% 
         filter(pool_short != "n"), aes(x = time, y = size, color = pool_short, group = plot.group))+geom_line(alpha = 0.5, size = 1.5)+
  scale_color_manual(name = "", breaks = c("b", "n", "f"), labels = c("Host biomass", "Host nitrogen", "Fungal biomass"), values = c(b.color, n.color, f.color))+
  labs(x = "Time (yrs)", y = "Pool sizes")+theme_minimal()+ guides(alpha =  FALSE)+ tp_bg+theme(legend.box = "horizontal", legend.position = c(0.8, 0.15))

ggsave(plot = nearneutralplot, filename = here('esa/figures/nearneutralplot.png'), width = 7/1.5, height = 5/1.5)

```

:::{.fragment fragment-index=2}

![](figures/nearneutralplot.png)
:::

:::
:::

## Varying partner preference

![](diagrams/2t2f_arrows.PNG){.absolute bottom=-80 left=50 width="350"}
![](diagrams/2t2f_separate_nonit.PNG){.absolute bottom=-80 right=50 width="350"}

::: columns
::: {.column width="50%"}
![](figures/stableplot.png)
:::

::: {.column width="50%"}
```{r, echo = FALSE}
st.pts = seq(10,30, length.out = 10)

for(j in 1:length(st.pts)){

primary.weight = 1 # how much preference each member of the network has for it's primary partner (e.g. Fungus 2's preference for Host 2)
#parameter values
tset = seq(from = 0, to = 100, by = 0.1) # a timeseries to iterate over
a <- 0.25 # host allocation to symbiont
p1 <- 0.5#(sin((2*pi/1000)*tset) + 1) / 2 # host 1 photosynthetic rate
p2 <- 0.5#1-(sin((2*pi/1000)*tset) + 1) / 2 # host 2 photosynthetic rate
mB1 <- .15 # host 1 mortality
mB2 <- .15 # host 2 mortality
mN1 <- mB1 # host 1 nitrogen loss rate
mN2 <- mB2 # host 2 nitrogen loss rate
r11 <- primary.weight # preference of host 1 toward fungus 1
r12 <- 1-r11 # preference of host 1 toward fungus 2
r22 <- primary.weight # preference of host 2 toward fungus 2
r21 <- 1-r22 # preference of host 2 toward fungus 1
epsilon <- 0.15 # fungal conversion efficiency
mF1 <- 0.1 # fungus 1 mortality rate
mF2 <- mF1 # fungus 2 mortality rate
u1 <- .25 # fungus 1 uptake rate
u2 <- .25 # fungus 2 uptake rate
s11 <- primary.weight # preference of fungus 1 toward host 1
s12 <- 1-s11 # preference of fungus 1 toward host 2
s22 <- primary.weight # preference of fungus 2 toward host 2
s21 <- 1-s22 # preference of fungus 2 toward host 1
N0 <- 100 # total system nitrogen
l.h = 1 # percent of tree resources lost from ROI allocation
l.s = 1 # percent of fungal resources lost from ROI allocation


#holding vectors and initial conditions
b1.set = rep(NaN, length(tset)); b1.set[1] <- 50
b2.set = rep(NaN, length(tset)); b2.set[1] <- st.pts[j]
n1.set = rep(NaN, length(tset)); n1.set[1] <- b1.set[1]*0.5
n2.set = rep(NaN, length(tset)); n2.set[1] <- b2.set[1]*0.5
f1.set = rep(NaN, length(tset)); f1.set[1] <- b1.set[1]*0.15
f2.set = rep(NaN, length(tset)); f2.set[1] <- b2.set[1]*0.15
e.set = rep(NaN, length(tset));  e.set[1]  <- 100 - n1.set[1]-n2.set[1]

#historical sharing percentages based on relative size of each 
c1f1.set = rep(NaN, length(tset)); c1f1.set[1] <- f1.set[1]/(f1.set[1]+f2.set[1])
c1f2.set = rep(NaN, length(tset)); c1f2.set[1] <- f2.set[1]/(f1.set[1]+f2.set[1])
c2f1.set = rep(NaN, length(tset)); c2f1.set[1] <- f1.set[1]/(f1.set[1]+f2.set[1])
c2f2.set = rep(NaN, length(tset)); c2f2.set[1] <- f2.set[1]/(f1.set[1]+f2.set[1])
f1n1.set = rep(NaN, length(tset)); f1n1.set[1] <- b1.set[1]/(b1.set[1]+b2.set[1])
f1n2.set = rep(NaN, length(tset)); f1n2.set[1] <- b2.set[1]/(b1.set[1]+b2.set[1])
f2n1.set = rep(NaN, length(tset)); f2n1.set[1] <- b1.set[1]/(b1.set[1]+b2.set[1])
f2n2.set = rep(NaN, length(tset)); f2n2.set[1] <- b2.set[1]/(b1.set[1]+b2.set[1])


for(i in 2:length(tset)){
  dt <- tset[i]-tset[i-1]
  B1 <- b1.set[i-1];  N1 <- n1.set[i-1]; F1 <- f1.set[i-1]
  B2 <- b2.set[i-1];  N2 <- n2.set[i-1];F2 <- f2.set[i-1]; E <- e.set[i-1]
  c1tof1 <- c1f1.set[i-1]; c1tof2 <- c1f2.set[i-1]; c2tof1 <- c2f1.set[i-1]; c2tof2 <- c2f2.set[i-1]
  f1ton1 <- f1n1.set[i-1]; f1ton2 <- f1n2.set[i-1]; f2ton1 <- f2n1.set[i-1]; f2ton2 <- f2n2.set[i-1]

  dB1 <- (p1 * N1 - (a + mB1)*B1)*dt
  dN1 <- (E*(u1*(F1*f1ton1*(1-l.s)+F1*s11*l.s)+u2*(F2*f2ton1*(1-l.s)+F2*s21*l.s))-mN1*N1)*dt
  dB2 <- (p2 * N2 - (a + mB2)*B2)*dt
  dN2 <- (E*(u1*F1*f1ton2*(1-l.s)+u1*F1*s12*l.s+u2*F2*f2ton2*(1-l.s)+u2*F2*s22*l.s)-mN2*N2)*dt
  dF1 <- ((a*B1*c1tof1*(1-l.h)+l.h*a*B1*r11)*epsilon+(a*B2*c2tof1*(1-l.h)+l.h*a*B2*r21)*epsilon-mF1*F1)*dt
  dF2 <- ((a*B1*c1tof2*(1-l.h)+l.h*a*B1*r12)*epsilon+(a*B2*c2tof2*(1-l.h)+l.h*a*B2*r22)*epsilon-mF2*F2)*dt

c1tof1.new <- r11*u1*(F1*f1ton1*(1-l.s)+F1*s11*l.s)/(r11*u1*(F1*f1ton1*(1-l.s)+F1*s11*l.s)+r12*u2*(F2*f2ton1*(1-l.s)+F2*s21*l.s))
c1tof2.new <- r12*u2*(F2*f2ton1*(1-l.s)+F2*s21*l.s)/(r11*u1*(F1*f1ton1*(1-l.s)+F1*s11*l.s)+r12*u2*(F2*f2ton1*(1-l.s)+F2*s21*l.s))
c2tof1.new <- r21*u1*(F1*f1ton2*(1-l.s)+F1*s12*l.s)/(r21*u1*(F1*f1ton2*(1-l.s)+F1*s12*l.s)+r22*u2*(F2*f2ton2*(1-l.s)+F2*s22*l.s))
c2tof2.new <- r22*u2*(F2*f2ton2*(1-l.s)+F2*s22*l.s)/(r21*u1*(F1*f1ton2*(1-l.s)+F1*s12*l.s)+r22*u2*(F2*f2ton2*(1-l.s)+F2*s22*l.s))
f1ton1.new <- s11*(a*B1*c1tof1*(1-l.h)+l.h*a*B1*r11)/(s11*(a*B1*c1tof1*(1-l.h)+l.h*a*B1*r11)+s12*(a*B2*c2tof1*(1-l.h)+l.h*a*B2*r21))
f1ton2.new <- s12*(a*B2*c2tof1*(1-l.h)+l.h*a*B2*r21)/(s11*(a*B1*c1tof1*(1-l.h)+l.h*a*B1*r11)+s12*(a*B2*c2tof1*(1-l.h)+l.h*a*B2*r21))
f2ton1.new <- s21*(a*B1*c1tof2*(1-l.h)+l.h*a*B1*r12)/(s21*(a*B1*c1tof2*(1-l.h)+l.h*a*B1*r12)+s22*(a*B2*c2tof2*(1-l.h)+l.h*a*B2*r22))
f2ton2.new <- s22*(a*B2*c2tof2*(1-l.h)+l.h*a*B2*r22)/(s21*(a*B1*c1tof2*(1-l.h)+l.h*a*B1*r12)+s22*(a*B2*c2tof2*(1-l.h)+l.h*a*B2*r22))

b1.set[i] <- B1 + dB1;n1.set[i] <- N1 + dN1;f1.set[i] <- F1 + dF1
b2.set[i] <- B2 + dB2;n2.set[i] <- N2 + dN2;f2.set[i] <- F2 + dF2;e.set[i] <- E - (dN1 + dN2)
  
c1f1.set[i]<- c1tof1.new;c1f2.set[i]<- c1tof2.new;c2f1.set[i]<- c2tof1.new;c2f2.set[i]<- c2tof2.new
f1n1.set[i]<- f1ton1.new;f1n2.set[i]<- f1ton2.new;f2n1.set[i]<- f2ton1.new;f2n2.set[i]<- f2ton2.new
}

if(j == 1)
{total.2t2f = tibble(time = tset) %>% 
  mutate(b1 = b1.set)%>% 
  mutate(b2 = b2.set)%>% 
  mutate(n1 = n1.set)%>% 
  mutate(n2 = n2.set) %>% 
  mutate(f1 = f1.set)%>% 
  mutate(f2 = f2.set) %>% 
  mutate(st.pt = b2.set[1])}
if(j>1)
{loop.df = tibble(time = tset) %>% 
  mutate(b1 = b1.set)%>% 
  mutate(b2 = b2.set)%>% 
  mutate(n1 = n1.set)%>% 
  mutate(n2 = n2.set) %>% 
  mutate(f1 = f1.set)%>% 
  mutate(f2 = f2.set) %>% 
  mutate(st.pt = b2.set[1])
  total.2t2f = total.2t2f %>% 
    bind_rows(loop.df)}
}
long.2t2f = total.2t2f %>% 
  pivot_longer(cols = b1:f2, names_to = "pool", values_to = 'size') %>% 
  mutate(plot.group = paste0(pool, st.pt)) %>% 
  group_by(plot.group) %>% 
  mutate(pool_short = str_sub(pool, 1,1))


neutralplot = ggplot(long.2t2f %>% 
         filter(pool_short != "n"), aes(x = time, y = size, color = pool_short, group = plot.group))+geom_line(alpha = 0.5, size = 1.5)+
  scale_color_manual(name = "", breaks = c("b", "n", "f"), labels = c("Host biomass", "Host nitrogen", "Fungal biomass"), values = c(b.color, n.color, f.color))+
  labs(x = "Time (yrs)", y = "Pool sizes")+theme_minimal()+ guides(alpha =  FALSE)+ tp_bg+theme(legend.box = "horizontal", legend.position = c(0.8, 0.15))

ggsave(plot = neutralplot, filename = here('esa/figures/neutralplot.png'), width = 7/1.5, height = 5/1.5)

```

:::{.fragment fragment-index=1}
![](figures/neutralplot.png)
:::

:::
:::

## Varying ROI
```{r, echo = FALSE, eval = F}
st.pts = seq(10,30, length.out = 10)
for(j in 1:length(st.pts)){

primary.weight = .75 # how much preference each member of the network has for it's primary partner (e.g. Fungus 2's preference for Host 2)
#parameter values
tset = seq(from = 0, to = 100, by = 0.01) # a timeseries to iterate over
a <- 0.25 # host allocation to symbiont
p1 <- 0.5#(sin((2*pi/1000)*tset) + 1) / 2 # host 1 photosynthetic rate
p2 <- 0.5#1-(sin((2*pi/1000)*tset) + 1) / 2 # host 2 photosynthetic rate
mB1 <- .15 # host 1 mortality
mB2 <- .15 # host 2 mortality
mN1 <- mB1 # host 1 nitrogen loss rate
mN2 <- mB2 # host 2 nitrogen loss rate
r11 <- primary.weight # preference of host 1 toward fungus 1
r12 <- 1-r11 # preference of host 1 toward fungus 2
r22 <- primary.weight # preference of host 2 toward fungus 2
r21 <- 1-r22 # preference of host 2 toward fungus 1
epsilon <- 0.15 # fungal conversion efficiency
mF1 <- 0.1 # fungus 1 mortality rate
mF2 <- mF1 # fungus 2 mortality rate
u1 <- .25 # fungus 1 uptake rate
u2 <- .25 # fungus 2 uptake rate
s11 <- primary.weight # preference of fungus 1 toward host 1
s12 <- 1-s11 # preference of fungus 1 toward host 2
s22 <- primary.weight # preference of fungus 2 toward host 2
s21 <- 1-s22 # preference of fungus 2 toward host 1
N0 <- 100 # total system nitrogen
l.h = 0 # percent of tree resources lost from ROI allocation
l.s = 0 # percent of fungal resources lost from ROI allocation


#holding vectors and initial conditions
b1.set = rep(NaN, length(tset)); b1.set[1] <- 50
b2.set = rep(NaN, length(tset)); b2.set[1] <- st.pts[j]
n1.set = rep(NaN, length(tset)); n1.set[1] <- b1.set[1]*0.5
n2.set = rep(NaN, length(tset)); n2.set[1] <- b2.set[1]*0.5
f1.set = rep(NaN, length(tset)); f1.set[1] <- b1.set[1]*0.15
f2.set = rep(NaN, length(tset)); f2.set[1] <- b2.set[1]*0.15
e.set = rep(NaN, length(tset));  e.set[1]  <- 100 - n1.set[1]-n2.set[1]

#historical sharing percentages based on relative size of each 
c1f1.set = rep(NaN, length(tset)); c1f1.set[1] <- f1.set[1]/(f1.set[1]+f2.set[1])
c1f2.set = rep(NaN, length(tset)); c1f2.set[1] <- f2.set[1]/(f1.set[1]+f2.set[1])
c2f1.set = rep(NaN, length(tset)); c2f1.set[1] <- f1.set[1]/(f1.set[1]+f2.set[1])
c2f2.set = rep(NaN, length(tset)); c2f2.set[1] <- f2.set[1]/(f1.set[1]+f2.set[1])
f1n1.set = rep(NaN, length(tset)); f1n1.set[1] <- b1.set[1]/(b1.set[1]+b2.set[1])
f1n2.set = rep(NaN, length(tset)); f1n2.set[1] <- b2.set[1]/(b1.set[1]+b2.set[1])
f2n1.set = rep(NaN, length(tset)); f2n1.set[1] <- b1.set[1]/(b1.set[1]+b2.set[1])
f2n2.set = rep(NaN, length(tset)); f2n2.set[1] <- b2.set[1]/(b1.set[1]+b2.set[1])


for(i in 2:length(tset)){
  dt <- tset[i]-tset[i-1]
  B1 <- b1.set[i-1];  N1 <- n1.set[i-1]; F1 <- f1.set[i-1]
  B2 <- b2.set[i-1];  N2 <- n2.set[i-1];F2 <- f2.set[i-1]; E <- e.set[i-1]
  c1tof1 <- c1f1.set[i-1]; c1tof2 <- c1f2.set[i-1]; c2tof1 <- c2f1.set[i-1]; c2tof2 <- c2f2.set[i-1]
  f1ton1 <- f1n1.set[i-1]; f1ton2 <- f1n2.set[i-1]; f2ton1 <- f2n1.set[i-1]; f2ton2 <- f2n2.set[i-1]

  dB1 <- (p1 * N1 - (a + mB1)*B1)*dt
  dN1 <- (E*(u1*(F1*f1ton1*(1-l.s)+F1*s11*l.s)+u2*(F2*f2ton1*(1-l.s)+F2*s21*l.s))-mN1*N1)*dt
  dB2 <- (p2 * N2 - (a + mB2)*B2)*dt
  dN2 <- (E*(u1*F1*f1ton2*(1-l.s)+u1*F1*s12*l.s+u2*F2*f2ton2*(1-l.s)+u2*F2*s22*l.s)-mN2*N2)*dt
  dF1 <- ((a*B1*c1tof1*(1-l.h)+l.h*a*B1*r11)*epsilon+(a*B2*c2tof1*(1-l.h)+l.h*a*B2*r21)*epsilon-mF1*F1)*dt
  dF2 <- ((a*B1*c1tof2*(1-l.h)+l.h*a*B1*r12)*epsilon+(a*B2*c2tof2*(1-l.h)+l.h*a*B2*r22)*epsilon-mF2*F2)*dt

c1tof1.new <- r11*u1*(F1*f1ton1*(1-l.s)+F1*s11*l.s)/(r11*u1*(F1*f1ton1*(1-l.s)+F1*s11*l.s)+r12*u2*(F2*f2ton1*(1-l.s)+F2*s21*l.s))
c1tof2.new <- r12*u2*(F2*f2ton1*(1-l.s)+F2*s21*l.s)/(r11*u1*(F1*f1ton1*(1-l.s)+F1*s11*l.s)+r12*u2*(F2*f2ton1*(1-l.s)+F2*s21*l.s))
c2tof1.new <- r21*u1*(F1*f1ton2*(1-l.s)+F1*s12*l.s)/(r21*u1*(F1*f1ton2*(1-l.s)+F1*s12*l.s)+r22*u2*(F2*f2ton2*(1-l.s)+F2*s22*l.s))
c2tof2.new <- r22*u2*(F2*f2ton2*(1-l.s)+F2*s22*l.s)/(r21*u1*(F1*f1ton2*(1-l.s)+F1*s12*l.s)+r22*u2*(F2*f2ton2*(1-l.s)+F2*s22*l.s))
f1ton1.new <- s11*(a*B1*c1tof1*(1-l.h)+l.h*a*B1*r11)/(s11*(a*B1*c1tof1*(1-l.h)+l.h*a*B1*r11)+s12*(a*B2*c2tof1*(1-l.h)+l.h*a*B2*r21))
f1ton2.new <- s12*(a*B2*c2tof1*(1-l.h)+l.h*a*B2*r21)/(s11*(a*B1*c1tof1*(1-l.h)+l.h*a*B1*r11)+s12*(a*B2*c2tof1*(1-l.h)+l.h*a*B2*r21))
f2ton1.new <- s21*(a*B1*c1tof2*(1-l.h)+l.h*a*B1*r12)/(s21*(a*B1*c1tof2*(1-l.h)+l.h*a*B1*r12)+s22*(a*B2*c2tof2*(1-l.h)+l.h*a*B2*r22))
f2ton2.new <- s22*(a*B2*c2tof2*(1-l.h)+l.h*a*B2*r22)/(s21*(a*B1*c1tof2*(1-l.h)+l.h*a*B1*r12)+s22*(a*B2*c2tof2*(1-l.h)+l.h*a*B2*r22))

b1.set[i] <- B1 + dB1;n1.set[i] <- N1 + dN1;f1.set[i] <- F1 + dF1
b2.set[i] <- B2 + dB2;n2.set[i] <- N2 + dN2;f2.set[i] <- F2 + dF2;e.set[i] <- E - (dN1 + dN2)
  
c1f1.set[i]<- c1tof1.new;c1f2.set[i]<- c1tof2.new;c2f1.set[i]<- c2tof1.new;c2f2.set[i]<- c2tof2.new
f1n1.set[i]<- f1ton1.new;f1n2.set[i]<- f1ton2.new;f2n1.set[i]<- f2ton1.new;f2n2.set[i]<- f2ton2.new
}

if(j == 1)
{total.2t2f = tibble(time = tset) %>% 
  mutate(b1 = b1.set)%>% 
  mutate(b2 = b2.set)%>% 
  mutate(n1 = n1.set)%>% 
  mutate(n2 = n2.set) %>% 
  mutate(f1 = f1.set)%>% 
  mutate(f2 = f2.set) %>% 
  mutate(st.pt = b2.set[1])}
if(j>1)
{loop.df = tibble(time = tset) %>% 
  mutate(b1 = b1.set)%>% 
  mutate(b2 = b2.set)%>% 
  mutate(n1 = n1.set)%>% 
  mutate(n2 = n2.set) %>% 
  mutate(f1 = f1.set)%>% 
  mutate(f2 = f2.set) %>% 
  mutate(st.pt = b2.set[1])
  total.2t2f = total.2t2f %>% 
    bind_rows(loop.df)}
}
long.2t2f = total.2t2f %>% 
  pivot_longer(cols = b1:f2, names_to = "pool", values_to = 'size') %>% 
  mutate(plot.group = paste0(pool, st.pt)) %>% 
  group_by(plot.group) %>% 
  mutate(pool_short = str_sub(pool, 1,1))


plot.roi.1.0 = ggplot(long.2t2f %>% 
         filter(pool_short != "n"), aes(x = time, y = size, color = pool_short, group = plot.group))+geom_line(alpha = 0.5, size = 1.5)+
  scale_color_manual(name = "", breaks = c("b", "n", "f"), labels = c("Host biomass", "Host nitrogen", "Fungal biomass"), values = c(b.color, n.color, f.color))+
  labs(x = "Time (yrs)", y = "Pool sizes")+theme_minimal()+ guides(alpha =  FALSE)+ tp_bg+theme(legend.box = "horizontal", legend.position = c(0.8, 0.15))

st.pts = seq(10,30, length.out = 10)
for(j in 1:length(st.pts)){


#parameter values
tset = seq(from = 0, to = 100, by = 0.01) # a timeseries to iterate over
a <- 0.25 # host allocation to symbiont
p1 <- 0.5#(sin((2*pi/1000)*tset) + 1) / 2 # host 1 photosynthetic rate
p2 <- 0.5#1-(sin((2*pi/1000)*tset) + 1) / 2 # host 2 photosynthetic rate
mB1 <- .15 # host 1 mortality
mB2 <- .15 # host 2 mortality
mN1 <- mB1 # host 1 nitrogen loss rate
mN2 <- mB2 # host 2 nitrogen loss rate
r11 <- primary.weight # preference of host 1 toward fungus 1
r12 <- 1-r11 # preference of host 1 toward fungus 2
r22 <- primary.weight # preference of host 2 toward fungus 2
r21 <- 1-r22 # preference of host 2 toward fungus 1
epsilon <- 0.15 # fungal conversion efficiency
mF1 <- 0.1 # fungus 1 mortality rate
mF2 <- mF1 # fungus 2 mortality rate
u1 <- .25 # fungus 1 uptake rate
u2 <- .25 # fungus 2 uptake rate
s11 <- primary.weight # preference of fungus 1 toward host 1
s12 <- 1-s11 # preference of fungus 1 toward host 2
s22 <- primary.weight # preference of fungus 2 toward host 2
s21 <- 1-s22 # preference of fungus 2 toward host 1
N0 <- 100 # total system nitrogen
l.h = 0.5 # percent of tree resources lost from ROI allocation
l.s = 0.5 # percent of fungal resources lost from ROI allocation


#holding vectors and initial conditions
b1.set = rep(NaN, length(tset)); b1.set[1] <- 50
b2.set = rep(NaN, length(tset)); b2.set[1] <- st.pts[j]
n1.set = rep(NaN, length(tset)); n1.set[1] <- b1.set[1]*0.5
n2.set = rep(NaN, length(tset)); n2.set[1] <- b2.set[1]*0.5
f1.set = rep(NaN, length(tset)); f1.set[1] <- b1.set[1]*0.15
f2.set = rep(NaN, length(tset)); f2.set[1] <- b2.set[1]*0.15
e.set = rep(NaN, length(tset));  e.set[1]  <- 100 - n1.set[1]-n2.set[1]

#historical sharing percentages based on relative size of each 
c1f1.set = rep(NaN, length(tset)); c1f1.set[1] <- f1.set[1]/(f1.set[1]+f2.set[1])
c1f2.set = rep(NaN, length(tset)); c1f2.set[1] <- f2.set[1]/(f1.set[1]+f2.set[1])
c2f1.set = rep(NaN, length(tset)); c2f1.set[1] <- f1.set[1]/(f1.set[1]+f2.set[1])
c2f2.set = rep(NaN, length(tset)); c2f2.set[1] <- f2.set[1]/(f1.set[1]+f2.set[1])
f1n1.set = rep(NaN, length(tset)); f1n1.set[1] <- b1.set[1]/(b1.set[1]+b2.set[1])
f1n2.set = rep(NaN, length(tset)); f1n2.set[1] <- b2.set[1]/(b1.set[1]+b2.set[1])
f2n1.set = rep(NaN, length(tset)); f2n1.set[1] <- b1.set[1]/(b1.set[1]+b2.set[1])
f2n2.set = rep(NaN, length(tset)); f2n2.set[1] <- b2.set[1]/(b1.set[1]+b2.set[1])


for(i in 2:length(tset)){
  dt <- tset[i]-tset[i-1]
  B1 <- b1.set[i-1];  N1 <- n1.set[i-1]; F1 <- f1.set[i-1]
  B2 <- b2.set[i-1];  N2 <- n2.set[i-1];F2 <- f2.set[i-1]; E <- e.set[i-1]
  c1tof1 <- c1f1.set[i-1]; c1tof2 <- c1f2.set[i-1]; c2tof1 <- c2f1.set[i-1]; c2tof2 <- c2f2.set[i-1]
  f1ton1 <- f1n1.set[i-1]; f1ton2 <- f1n2.set[i-1]; f2ton1 <- f2n1.set[i-1]; f2ton2 <- f2n2.set[i-1]

  dB1 <- (p1 * N1 - (a + mB1)*B1)*dt
  dN1 <- (E*(u1*(F1*f1ton1*(1-l.s)+F1*s11*l.s)+u2*(F2*f2ton1*(1-l.s)+F2*s21*l.s))-mN1*N1)*dt
  dB2 <- (p2 * N2 - (a + mB2)*B2)*dt
  dN2 <- (E*(u1*F1*f1ton2*(1-l.s)+u1*F1*s12*l.s+u2*F2*f2ton2*(1-l.s)+u2*F2*s22*l.s)-mN2*N2)*dt
  dF1 <- ((a*B1*c1tof1*(1-l.h)+l.h*a*B1*r11)*epsilon+(a*B2*c2tof1*(1-l.h)+l.h*a*B2*r21)*epsilon-mF1*F1)*dt
  dF2 <- ((a*B1*c1tof2*(1-l.h)+l.h*a*B1*r12)*epsilon+(a*B2*c2tof2*(1-l.h)+l.h*a*B2*r22)*epsilon-mF2*F2)*dt

c1tof1.new <- r11*u1*(F1*f1ton1*(1-l.s)+F1*s11*l.s)/(r11*u1*(F1*f1ton1*(1-l.s)+F1*s11*l.s)+r12*u2*(F2*f2ton1*(1-l.s)+F2*s21*l.s))
c1tof2.new <- r12*u2*(F2*f2ton1*(1-l.s)+F2*s21*l.s)/(r11*u1*(F1*f1ton1*(1-l.s)+F1*s11*l.s)+r12*u2*(F2*f2ton1*(1-l.s)+F2*s21*l.s))
c2tof1.new <- r21*u1*(F1*f1ton2*(1-l.s)+F1*s12*l.s)/(r21*u1*(F1*f1ton2*(1-l.s)+F1*s12*l.s)+r22*u2*(F2*f2ton2*(1-l.s)+F2*s22*l.s))
c2tof2.new <- r22*u2*(F2*f2ton2*(1-l.s)+F2*s22*l.s)/(r21*u1*(F1*f1ton2*(1-l.s)+F1*s12*l.s)+r22*u2*(F2*f2ton2*(1-l.s)+F2*s22*l.s))
f1ton1.new <- s11*(a*B1*c1tof1*(1-l.h)+l.h*a*B1*r11)/(s11*(a*B1*c1tof1*(1-l.h)+l.h*a*B1*r11)+s12*(a*B2*c2tof1*(1-l.h)+l.h*a*B2*r21))
f1ton2.new <- s12*(a*B2*c2tof1*(1-l.h)+l.h*a*B2*r21)/(s11*(a*B1*c1tof1*(1-l.h)+l.h*a*B1*r11)+s12*(a*B2*c2tof1*(1-l.h)+l.h*a*B2*r21))
f2ton1.new <- s21*(a*B1*c1tof2*(1-l.h)+l.h*a*B1*r12)/(s21*(a*B1*c1tof2*(1-l.h)+l.h*a*B1*r12)+s22*(a*B2*c2tof2*(1-l.h)+l.h*a*B2*r22))
f2ton2.new <- s22*(a*B2*c2tof2*(1-l.h)+l.h*a*B2*r22)/(s21*(a*B1*c1tof2*(1-l.h)+l.h*a*B1*r12)+s22*(a*B2*c2tof2*(1-l.h)+l.h*a*B2*r22))

b1.set[i] <- B1 + dB1;n1.set[i] <- N1 + dN1;f1.set[i] <- F1 + dF1
b2.set[i] <- B2 + dB2;n2.set[i] <- N2 + dN2;f2.set[i] <- F2 + dF2;e.set[i] <- E - (dN1 + dN2)
  
c1f1.set[i]<- c1tof1.new;c1f2.set[i]<- c1tof2.new;c2f1.set[i]<- c2tof1.new;c2f2.set[i]<- c2tof2.new
f1n1.set[i]<- f1ton1.new;f1n2.set[i]<- f1ton2.new;f2n1.set[i]<- f2ton1.new;f2n2.set[i]<- f2ton2.new
}

if(j == 1)
{total.2t2f = tibble(time = tset) %>% 
  mutate(b1 = b1.set)%>% 
  mutate(b2 = b2.set)%>% 
  mutate(n1 = n1.set)%>% 
  mutate(n2 = n2.set) %>% 
  mutate(f1 = f1.set)%>% 
  mutate(f2 = f2.set) %>% 
  mutate(st.pt = b2.set[1])}
if(j>1)
{loop.df = tibble(time = tset) %>% 
  mutate(b1 = b1.set)%>% 
  mutate(b2 = b2.set)%>% 
  mutate(n1 = n1.set)%>% 
  mutate(n2 = n2.set) %>% 
  mutate(f1 = f1.set)%>% 
  mutate(f2 = f2.set) %>% 
  mutate(st.pt = b2.set[1])
  total.2t2f = total.2t2f %>% 
    bind_rows(loop.df)}
}
long.2t2f = total.2t2f %>% 
  pivot_longer(cols = b1:f2, names_to = "pool", values_to = 'size') %>% 
  mutate(plot.group = paste0(pool, st.pt)) %>% 
  group_by(plot.group) %>% 
  mutate(pool_short = str_sub(pool, 1,1))


plot.roi.0.5 = ggplot(long.2t2f %>% 
         filter(pool_short != "n"), aes(x = time, y = size, color = pool_short, group = plot.group))+geom_line(alpha = 0.5, size = 1.5)+
  scale_color_manual(name = "", breaks = c("b", "n", "f"), labels = c("Host biomass", "Host nitrogen", "Fungal biomass"), values = c(b.color, n.color, f.color))+
  labs(x = "Time (yrs)", y = "Pool sizes")+theme_minimal()+ guides(alpha =  FALSE)+ tp_bg+theme(legend.box = "horizontal", legend.position = c(0.8, 0.15))

st.pts = seq(10,30, length.out = 10)
for(j in 1:length(st.pts)){

#parameter values
tset = seq(from = 0, to = 100, by = 0.01) # a timeseries to iterate over
a <- 0.25 # host allocation to symbiont
p1 <- 0.5#(sin((2*pi/1000)*tset) + 1) / 2 # host 1 photosynthetic rate
p2 <- 0.5#1-(sin((2*pi/1000)*tset) + 1) / 2 # host 2 photosynthetic rate
mB1 <- .15 # host 1 mortality
mB2 <- .15 # host 2 mortality
mN1 <- mB1 # host 1 nitrogen loss rate
mN2 <- mB2 # host 2 nitrogen loss rate
r11 <- primary.weight # preference of host 1 toward fungus 1
r12 <- 1-r11 # preference of host 1 toward fungus 2
r22 <- primary.weight # preference of host 2 toward fungus 2
r21 <- 1-r22 # preference of host 2 toward fungus 1
epsilon <- 0.15 # fungal conversion efficiency
mF1 <- 0.1 # fungus 1 mortality rate
mF2 <- mF1 # fungus 2 mortality rate
u1 <- .25 # fungus 1 uptake rate
u2 <- .25 # fungus 2 uptake rate
s11 <- primary.weight # preference of fungus 1 toward host 1
s12 <- 1-s11 # preference of fungus 1 toward host 2
s22 <- primary.weight # preference of fungus 2 toward host 2
s21 <- 1-s22 # preference of fungus 2 toward host 1
N0 <- 100 # total system nitrogen
l.h = 1 # percent of tree resources lost from ROI allocation
l.s = 1 # percent of fungal resources lost from ROI allocation


#holding vectors and initial conditions
b1.set = rep(NaN, length(tset)); b1.set[1] <- 50
b2.set = rep(NaN, length(tset)); b2.set[1] <- st.pts[j]
n1.set = rep(NaN, length(tset)); n1.set[1] <- b1.set[1]*0.5
n2.set = rep(NaN, length(tset)); n2.set[1] <- b2.set[1]*0.5
f1.set = rep(NaN, length(tset)); f1.set[1] <- b1.set[1]*0.15
f2.set = rep(NaN, length(tset)); f2.set[1] <- b2.set[1]*0.15
e.set = rep(NaN, length(tset));  e.set[1]  <- 100 - n1.set[1]-n2.set[1]

#historical sharing percentages based on relative size of each 
c1f1.set = rep(NaN, length(tset)); c1f1.set[1] <- f1.set[1]/(f1.set[1]+f2.set[1])
c1f2.set = rep(NaN, length(tset)); c1f2.set[1] <- f2.set[1]/(f1.set[1]+f2.set[1])
c2f1.set = rep(NaN, length(tset)); c2f1.set[1] <- f1.set[1]/(f1.set[1]+f2.set[1])
c2f2.set = rep(NaN, length(tset)); c2f2.set[1] <- f2.set[1]/(f1.set[1]+f2.set[1])
f1n1.set = rep(NaN, length(tset)); f1n1.set[1] <- b1.set[1]/(b1.set[1]+b2.set[1])
f1n2.set = rep(NaN, length(tset)); f1n2.set[1] <- b2.set[1]/(b1.set[1]+b2.set[1])
f2n1.set = rep(NaN, length(tset)); f2n1.set[1] <- b1.set[1]/(b1.set[1]+b2.set[1])
f2n2.set = rep(NaN, length(tset)); f2n2.set[1] <- b2.set[1]/(b1.set[1]+b2.set[1])


for(i in 2:length(tset)){
  dt <- tset[i]-tset[i-1]
  B1 <- b1.set[i-1];  N1 <- n1.set[i-1]; F1 <- f1.set[i-1]
  B2 <- b2.set[i-1];  N2 <- n2.set[i-1];F2 <- f2.set[i-1]; E <- e.set[i-1]
  c1tof1 <- c1f1.set[i-1]; c1tof2 <- c1f2.set[i-1]; c2tof1 <- c2f1.set[i-1]; c2tof2 <- c2f2.set[i-1]
  f1ton1 <- f1n1.set[i-1]; f1ton2 <- f1n2.set[i-1]; f2ton1 <- f2n1.set[i-1]; f2ton2 <- f2n2.set[i-1]

  dB1 <- (p1 * N1 - (a + mB1)*B1)*dt
  dN1 <- (E*(u1*(F1*f1ton1*(1-l.s)+F1*s11*l.s)+u2*(F2*f2ton1*(1-l.s)+F2*s21*l.s))-mN1*N1)*dt
  dB2 <- (p2 * N2 - (a + mB2)*B2)*dt
  dN2 <- (E*(u1*F1*f1ton2*(1-l.s)+u1*F1*s12*l.s+u2*F2*f2ton2*(1-l.s)+u2*F2*s22*l.s)-mN2*N2)*dt
  dF1 <- ((a*B1*c1tof1*(1-l.h)+l.h*a*B1*r11)*epsilon+(a*B2*c2tof1*(1-l.h)+l.h*a*B2*r21)*epsilon-mF1*F1)*dt
  dF2 <- ((a*B1*c1tof2*(1-l.h)+l.h*a*B1*r12)*epsilon+(a*B2*c2tof2*(1-l.h)+l.h*a*B2*r22)*epsilon-mF2*F2)*dt

c1tof1.new <- r11*u1*(F1*f1ton1*(1-l.s)+F1*s11*l.s)/(r11*u1*(F1*f1ton1*(1-l.s)+F1*s11*l.s)+r12*u2*(F2*f2ton1*(1-l.s)+F2*s21*l.s))
c1tof2.new <- r12*u2*(F2*f2ton1*(1-l.s)+F2*s21*l.s)/(r11*u1*(F1*f1ton1*(1-l.s)+F1*s11*l.s)+r12*u2*(F2*f2ton1*(1-l.s)+F2*s21*l.s))
c2tof1.new <- r21*u1*(F1*f1ton2*(1-l.s)+F1*s12*l.s)/(r21*u1*(F1*f1ton2*(1-l.s)+F1*s12*l.s)+r22*u2*(F2*f2ton2*(1-l.s)+F2*s22*l.s))
c2tof2.new <- r22*u2*(F2*f2ton2*(1-l.s)+F2*s22*l.s)/(r21*u1*(F1*f1ton2*(1-l.s)+F1*s12*l.s)+r22*u2*(F2*f2ton2*(1-l.s)+F2*s22*l.s))
f1ton1.new <- s11*(a*B1*c1tof1*(1-l.h)+l.h*a*B1*r11)/(s11*(a*B1*c1tof1*(1-l.h)+l.h*a*B1*r11)+s12*(a*B2*c2tof1*(1-l.h)+l.h*a*B2*r21))
f1ton2.new <- s12*(a*B2*c2tof1*(1-l.h)+l.h*a*B2*r21)/(s11*(a*B1*c1tof1*(1-l.h)+l.h*a*B1*r11)+s12*(a*B2*c2tof1*(1-l.h)+l.h*a*B2*r21))
f2ton1.new <- s21*(a*B1*c1tof2*(1-l.h)+l.h*a*B1*r12)/(s21*(a*B1*c1tof2*(1-l.h)+l.h*a*B1*r12)+s22*(a*B2*c2tof2*(1-l.h)+l.h*a*B2*r22))
f2ton2.new <- s22*(a*B2*c2tof2*(1-l.h)+l.h*a*B2*r22)/(s21*(a*B1*c1tof2*(1-l.h)+l.h*a*B1*r12)+s22*(a*B2*c2tof2*(1-l.h)+l.h*a*B2*r22))

b1.set[i] <- B1 + dB1;n1.set[i] <- N1 + dN1;f1.set[i] <- F1 + dF1
b2.set[i] <- B2 + dB2;n2.set[i] <- N2 + dN2;f2.set[i] <- F2 + dF2;e.set[i] <- E - (dN1 + dN2)
  
c1f1.set[i]<- c1tof1.new;c1f2.set[i]<- c1tof2.new;c2f1.set[i]<- c2tof1.new;c2f2.set[i]<- c2tof2.new
f1n1.set[i]<- f1ton1.new;f1n2.set[i]<- f1ton2.new;f2n1.set[i]<- f2ton1.new;f2n2.set[i]<- f2ton2.new
}

if(j == 1)
{total.2t2f = tibble(time = tset) %>% 
  mutate(b1 = b1.set)%>% 
  mutate(b2 = b2.set)%>% 
  mutate(n1 = n1.set)%>% 
  mutate(n2 = n2.set) %>% 
  mutate(f1 = f1.set)%>% 
  mutate(f2 = f2.set) %>% 
  mutate(st.pt = b2.set[1])}
if(j>1)
{loop.df = tibble(time = tset) %>% 
  mutate(b1 = b1.set)%>% 
  mutate(b2 = b2.set)%>% 
  mutate(n1 = n1.set)%>% 
  mutate(n2 = n2.set) %>% 
  mutate(f1 = f1.set)%>% 
  mutate(f2 = f2.set) %>% 
  mutate(st.pt = b2.set[1])
  total.2t2f = total.2t2f %>% 
    bind_rows(loop.df)}
}
long.2t2f = total.2t2f %>% 
  pivot_longer(cols = b1:f2, names_to = "pool", values_to = 'size') %>% 
  mutate(plot.group = paste0(pool, st.pt)) %>% 
  group_by(plot.group) %>% 
  mutate(pool_short = str_sub(pool, 1,1))


plot.roi.0.0 = ggplot(long.2t2f %>% 
         filter(pool_short != "n"), aes(x = time, y = size, color = pool_short, group = plot.group))+geom_line(alpha = 0.5, size = 1.5)+
  scale_color_manual(name = "", breaks = c("b", "n", "f"), labels = c("Host biomass", "Host nitrogen", "Fungal biomass"), values = c(b.color, n.color, f.color))+
  labs(x = "Time (yrs)", y = "Pool sizes")+theme_minimal()+ guides(alpha =  FALSE)+ tp_bg+theme(legend.box = "horizontal", legend.position = c(0.8, 0.15))



roi.plot = plot.roi.0.0+plot.roi.0.5+plot.roi.1.0 &
  plot_annotation(theme = theme(plot.background = element_blank()))

ggsave(plot = roi.plot, filename = here('esa/figures/roi_plot.png'), width = 15, height = 5)
```

![](figures/roi_plot.png){.absolute top=120 width="200%"}

![](images/investor.jpeg){.absolute top=500 left=470 width="75" height="75"}
![](images/investor.jpeg){.absolute top=500 right=125 width="125" height="125"}
![](images/investor.jpeg){.absolute top=500 left=165 width="40" height="40"}


# Synthesis
```{r, echo = FALSE, eval = F}
steps = 10
part.increments = seq(0.5, 1, length.out = steps)
roi.increments = seq(0, 1, length.out = steps)


samset = tibble(
  par.series = part.increments, 
  roi.series = roi.increments
)

samsetlong = samset %>% 
  expand.grid()
p.pref = as.vector(samsetlong$par.series)
roi = as.vector(samsetlong$roi.series)

for(j in 1:length(p.pref)){

primary.weight = p.pref[j] # how much preference each member of the network has for it's primary partner (e.g. Fungus 2's preference for Host 2)
#parameter values
tset = seq(from = 0, to = 1000, by = 0.1) # a timeseries to iterate over
a <- 0.25 # host allocation to symbiont
p1 <- 0.5#(sin((2*pi/1000)*tset) + 1) / 2 # host 1 photosynthetic rate
p2 <- 0.5#1-(sin((2*pi/1000)*tset) + 1) / 2 # host 2 photosynthetic rate
mB1 <- .15 # host 1 mortality
mB2 <- .15 # host 2 mortality
mN1 <- mB1 # host 1 nitrogen loss rate
mN2 <- mB2 # host 2 nitrogen loss rate
r11 <- primary.weight # preference of host 1 toward fungus 1
r12 <- 1-r11 # preference of host 1 toward fungus 2
r22 <- primary.weight # preference of host 2 toward fungus 2
r21 <- 1-r22 # preference of host 2 toward fungus 1
epsilon <- 0.15 # fungal conversion efficiency
mF1 <- 0.1 # fungus 1 mortality rate
mF2 <- mF1 # fungus 2 mortality rate
u1 <- .25 # fungus 1 uptake rate
u2 <- .25 # fungus 2 uptake rate
s11 <- primary.weight # preference of fungus 1 toward host 1
s12 <- 1-s11 # preference of fungus 1 toward host 2
s22 <- primary.weight # preference of fungus 2 toward host 2
s21 <- 1-s22 # preference of fungus 2 toward host 1
N0 <- 100 # total system nitrogen
l.h = roi[j] # percent of tree resources lost from ROI allocation
l.s = roi[j] # percent of fungal resources lost from ROI allocation


#holding vectors and initial conditions
b1.set = rep(NaN, length(tset)); b1.set[1] <- 50
b2.set = rep(NaN, length(tset)); b2.set[1] <- 50
n1.set = rep(NaN, length(tset)); n1.set[1] <- b1.set[1]*0.5
n2.set = rep(NaN, length(tset)); n2.set[1] <- b2.set[1]*0.5
f1.set = rep(NaN, length(tset)); f1.set[1] <- b1.set[1]*0.15
f2.set = rep(NaN, length(tset)); f2.set[1] <- b2.set[1]*0.15
e.set = rep(NaN, length(tset));  e.set[1]  <- 100 - n1.set[1]-n2.set[1]

#historical sharing percentages based on relative size of each 
c1f1.set = rep(NaN, length(tset)); c1f1.set[1] <- f1.set[1]/(f1.set[1]+f2.set[1])
c1f2.set = rep(NaN, length(tset)); c1f2.set[1] <- f2.set[1]/(f1.set[1]+f2.set[1])
c2f1.set = rep(NaN, length(tset)); c2f1.set[1] <- f1.set[1]/(f1.set[1]+f2.set[1])
c2f2.set = rep(NaN, length(tset)); c2f2.set[1] <- f2.set[1]/(f1.set[1]+f2.set[1])
f1n1.set = rep(NaN, length(tset)); f1n1.set[1] <- b1.set[1]/(b1.set[1]+b2.set[1])
f1n2.set = rep(NaN, length(tset)); f1n2.set[1] <- b2.set[1]/(b1.set[1]+b2.set[1])
f2n1.set = rep(NaN, length(tset)); f2n1.set[1] <- b1.set[1]/(b1.set[1]+b2.set[1])
f2n2.set = rep(NaN, length(tset)); f2n2.set[1] <- b2.set[1]/(b1.set[1]+b2.set[1])


for(i in 2:length(tset)){
  dt <- tset[i]-tset[i-1]
  B1 <- b1.set[i-1];  N1 <- n1.set[i-1]; F1 <- f1.set[i-1]
  B2 <- b2.set[i-1];  N2 <- n2.set[i-1];F2 <- f2.set[i-1]; E <- e.set[i-1]
  c1tof1 <- c1f1.set[i-1]; c1tof2 <- c1f2.set[i-1]; c2tof1 <- c2f1.set[i-1]; c2tof2 <- c2f2.set[i-1]
  f1ton1 <- f1n1.set[i-1]; f1ton2 <- f1n2.set[i-1]; f2ton1 <- f2n1.set[i-1]; f2ton2 <- f2n2.set[i-1]

  dB1 <- (p1 * N1 - (a + mB1)*B1)*dt
  dN1 <- (E*(u1*(F1*f1ton1*(1-l.s)+F1*s11*l.s)+u2*(F2*f2ton1*(1-l.s)+F2*s21*l.s))-mN1*N1)*dt
  dB2 <- (p2 * N2 - (a + mB2)*B2)*dt
  dN2 <- (E*(u1*F1*f1ton2*(1-l.s)+u1*F1*s12*l.s+u2*F2*f2ton2*(1-l.s)+u2*F2*s22*l.s)-mN2*N2)*dt
  dF1 <- ((a*B1*c1tof1*(1-l.h)+l.h*a*B1*r11)*epsilon+(a*B2*c2tof1*(1-l.h)+l.h*a*B2*r21)*epsilon-mF1*F1)*dt
  dF2 <- ((a*B1*c1tof2*(1-l.h)+l.h*a*B1*r12)*epsilon+(a*B2*c2tof2*(1-l.h)+l.h*a*B2*r22)*epsilon-mF2*F2)*dt

c1tof1.new <- r11*u1*(F1*f1ton1*(1-l.s)+F1*s11*l.s)/(r11*u1*(F1*f1ton1*(1-l.s)+F1*s11*l.s)+r12*u2*(F2*f2ton1*(1-l.s)+F2*s21*l.s))
c1tof2.new <- r12*u2*(F2*f2ton1*(1-l.s)+F2*s21*l.s)/(r11*u1*(F1*f1ton1*(1-l.s)+F1*s11*l.s)+r12*u2*(F2*f2ton1*(1-l.s)+F2*s21*l.s))
c2tof1.new <- r21*u1*(F1*f1ton2*(1-l.s)+F1*s12*l.s)/(r21*u1*(F1*f1ton2*(1-l.s)+F1*s12*l.s)+r22*u2*(F2*f2ton2*(1-l.s)+F2*s22*l.s))
c2tof2.new <- r22*u2*(F2*f2ton2*(1-l.s)+F2*s22*l.s)/(r21*u1*(F1*f1ton2*(1-l.s)+F1*s12*l.s)+r22*u2*(F2*f2ton2*(1-l.s)+F2*s22*l.s))
f1ton1.new <- s11*(a*B1*c1tof1*(1-l.h)+l.h*a*B1*r11)/(s11*(a*B1*c1tof1*(1-l.h)+l.h*a*B1*r11)+s12*(a*B2*c2tof1*(1-l.h)+l.h*a*B2*r21))
f1ton2.new <- s12*(a*B2*c2tof1*(1-l.h)+l.h*a*B2*r21)/(s11*(a*B1*c1tof1*(1-l.h)+l.h*a*B1*r11)+s12*(a*B2*c2tof1*(1-l.h)+l.h*a*B2*r21))
f2ton1.new <- s21*(a*B1*c1tof2*(1-l.h)+l.h*a*B1*r12)/(s21*(a*B1*c1tof2*(1-l.h)+l.h*a*B1*r12)+s22*(a*B2*c2tof2*(1-l.h)+l.h*a*B2*r22))
f2ton2.new <- s22*(a*B2*c2tof2*(1-l.h)+l.h*a*B2*r22)/(s21*(a*B1*c1tof2*(1-l.h)+l.h*a*B1*r12)+s22*(a*B2*c2tof2*(1-l.h)+l.h*a*B2*r22))


if(i == round(0.55*length(tset), 0))
{p1 = 0.75*p2}
if(i == round(0.6*length(tset), 0))
{p1 = p2}


b1.set[i] <- B1 + dB1;n1.set[i] <- N1 + dN1;f1.set[i] <- F1 + dF1
b2.set[i] <- B2 + dB2;n2.set[i] <- N2 + dN2;f2.set[i] <- F2 + dF2;e.set[i] <- E - (dN1 + dN2)
  
c1f1.set[i]<- c1tof1.new;c1f2.set[i]<- c1tof2.new;c2f1.set[i]<- c2tof1.new;c2f2.set[i]<- c2tof2.new
f1n1.set[i]<- f1ton1.new;f1n2.set[i]<- f1ton2.new;f2n1.set[i]<- f2ton1.new;f2n2.set[i]<- f2ton2.new
}

if(j == 1)
{total.2t2f = tibble(time = tset) %>% 
  mutate(b1 = b1.set)%>% 
  mutate(b2 = b2.set)%>% 
  mutate(n1 = n1.set)%>% 
  mutate(n2 = n2.set) %>% 
  mutate(f1 = f1.set)%>% 
  mutate(f2 = f2.set) %>% 
  mutate(roi = 1-l.h) %>% 
  mutate(pref = primary.weight) %>% 
  mutate(resistance= min(b1.set[round(0.55*length(tset),0):length(b1.set)])/b1.set[round(0.55*length(tset),0)]) %>% 
  mutate(resilience = max(tset)*(which(b1.set[round(0.6*length(tset),0):length(b1.set)] > 0.99*b1.set[round(0.55*length(tset),0)-1])[1] )/length(tset))}
if(j>1)
{loop.df = tibble(time = tset) %>% 
  mutate(b1 = b1.set)%>% 
  mutate(b2 = b2.set)%>% 
  mutate(n1 = n1.set)%>% 
  mutate(n2 = n2.set) %>% 
  mutate(f1 = f1.set)%>% 
  mutate(f2 = f2.set)  %>% 
  mutate(roi = 1-l.h) %>% 
  mutate(pref = primary.weight)%>% 
  mutate(resistance= min(b1.set[round(0.55*length(tset),0):length(b1.set)])/b1.set[round(0.55*length(tset),0)]) 
  total.2t2f = total.2t2f %>% 
    bind_rows(loop.df)}
}
long.sanc = total.2t2f %>% 
  pivot_longer(cols = b1:f2, names_to = "pool", values_to = 'size')%>% 
  mutate(pool_short = str_sub(pool, 1,1)) %>% 
  mutate(pref =2*( pref-0.5))


ggplot(total.2t2f %>% 
         filter(time == max(time)), aes(x = roi, y = pref, fill = b1))+
         geom_tile()

ggplot(total.2t2f %>% 
         filter(time == max(time)), aes(x = roi, y = pref, fill = resistance))+
         geom_tile()


#ggsave(plot = nearneutralplot, filename = here('esa/figures/nearneutralplot.png'), width = 7/1.5, height = 5/1.5)

```

```{r, echo = FALSE, eval = F}
steps = 10
part.increments = seq(0.51, .99, length.out = steps)
roi.increments = seq(0.01, .99, length.out = steps)


samset = tibble(
  par.series = part.increments, 
  roi.series = roi.increments
)

samsetlong = samset %>% 
  expand.grid()
p.pref = as.vector(samsetlong$par.series)
roi = as.vector(samsetlong$roi.series)

for(j in 1:length(p.pref)){

primary.weight = p.pref[j] # how much preference each member of the network has for it's primary partner (e.g. Fungus 2's preference for Host 2)
#parameter values
tset = seq(from = 0, to = 1000, by = 0.1) # a timeseries to iterate over
a <- 0.25 # host allocation to symbiont
p1 <- 0.5#(sin((2*pi/1000)*tset) + 1) / 2 # host 1 photosynthetic rate
p2 <- 0.5#1-(sin((2*pi/1000)*tset) + 1) / 2 # host 2 photosynthetic rate
mB1 <- .15 # host 1 mortality
mB2 <- .15 # host 2 mortality
mN1 <- mB1 # host 1 nitrogen loss rate
mN2 <- mB2 # host 2 nitrogen loss rate
r11 <- primary.weight # preference of host 1 toward fungus 1
r12 <- 1-r11 # preference of host 1 toward fungus 2
r22 <- primary.weight # preference of host 2 toward fungus 2
r21 <- 1-r22 # preference of host 2 toward fungus 1
epsilon <- 0.15 # fungal conversion efficiency
mF1 <- 0.1 # fungus 1 mortality rate
mF2 <- mF1 # fungus 2 mortality rate
u1 <- .25 # fungus 1 uptake rate
u2 <- .25 # fungus 2 uptake rate
s11 <- primary.weight # preference of fungus 1 toward host 1
s12 <- 1-s11 # preference of fungus 1 toward host 2
s22 <- primary.weight # preference of fungus 2 toward host 2
s21 <- 1-s22 # preference of fungus 2 toward host 1
N0 <- 100 # total system nitrogen
l.h = roi[j] # percent of tree resources lost from ROI allocation
l.s = 0 # percent of fungal resources lost from ROI allocation


#holding vectors and initial conditions
b1.set = rep(NaN, length(tset)); b1.set[1] <- 50
b2.set = rep(NaN, length(tset)); b2.set[1] <- 50
n1.set = rep(NaN, length(tset)); n1.set[1] <- b1.set[1]*0.5
n2.set = rep(NaN, length(tset)); n2.set[1] <- b2.set[1]*0.5
f1.set = rep(NaN, length(tset)); f1.set[1] <- b1.set[1]*0.15
f2.set = rep(NaN, length(tset)); f2.set[1] <- b2.set[1]*0.15
e.set = rep(NaN, length(tset));  e.set[1]  <- 100 - n1.set[1]-n2.set[1]

#historical sharing percentages based on relative size of each 
c1f1.set = rep(NaN, length(tset)); c1f1.set[1] <- f1.set[1]/(f1.set[1]+f2.set[1])
c1f2.set = rep(NaN, length(tset)); c1f2.set[1] <- f2.set[1]/(f1.set[1]+f2.set[1])
c2f1.set = rep(NaN, length(tset)); c2f1.set[1] <- f1.set[1]/(f1.set[1]+f2.set[1])
c2f2.set = rep(NaN, length(tset)); c2f2.set[1] <- f2.set[1]/(f1.set[1]+f2.set[1])
f1n1.set = rep(NaN, length(tset)); f1n1.set[1] <- b1.set[1]/(b1.set[1]+b2.set[1])
f1n2.set = rep(NaN, length(tset)); f1n2.set[1] <- b2.set[1]/(b1.set[1]+b2.set[1])
f2n1.set = rep(NaN, length(tset)); f2n1.set[1] <- b1.set[1]/(b1.set[1]+b2.set[1])
f2n2.set = rep(NaN, length(tset)); f2n2.set[1] <- b2.set[1]/(b1.set[1]+b2.set[1])


for(i in 2:length(tset)){
  dt <- tset[i]-tset[i-1]
  B1 <- b1.set[i-1];  N1 <- n1.set[i-1]; F1 <- f1.set[i-1]
  B2 <- b2.set[i-1];  N2 <- n2.set[i-1];F2 <- f2.set[i-1]; E <- e.set[i-1]
  c1tof1 <- c1f1.set[i-1]; c1tof2 <- c1f2.set[i-1]; c2tof1 <- c2f1.set[i-1]; c2tof2 <- c2f2.set[i-1]
  f1ton1 <- f1n1.set[i-1]; f1ton2 <- f1n2.set[i-1]; f2ton1 <- f2n1.set[i-1]; f2ton2 <- f2n2.set[i-1]

  dB1 <- (p1 * N1 - (a + mB1)*B1)*dt
  dN1 <- (E*(u1*(F1*f1ton1*(1-l.s)+F1*s11*l.s)+u2*(F2*f2ton1*(1-l.s)+F2*s21*l.s))-mN1*N1)*dt
  dB2 <- (p2 * N2 - (a + mB2)*B2)*dt
  dN2 <- (E*(u1*F1*f1ton2*(1-l.s)+u1*F1*s12*l.s+u2*F2*f2ton2*(1-l.s)+u2*F2*s22*l.s)-mN2*N2)*dt
  dF1 <- ((a*B1*c1tof1*(1-l.h)+l.h*a*B1*r11)*epsilon+(a*B2*c2tof1*(1-l.h)+l.h*a*B2*r21)*epsilon-mF1*F1)*dt
  dF2 <- ((a*B1*c1tof2*(1-l.h)+l.h*a*B1*r12)*epsilon+(a*B2*c2tof2*(1-l.h)+l.h*a*B2*r22)*epsilon-mF2*F2)*dt

c1tof1.new <- r11*u1*(F1*f1ton1*(1-l.s)+F1*s11*l.s)/(r11*u1*(F1*f1ton1*(1-l.s)+F1*s11*l.s)+r12*u2*(F2*f2ton1*(1-l.s)+F2*s21*l.s))
c1tof2.new <- r12*u2*(F2*f2ton1*(1-l.s)+F2*s21*l.s)/(r11*u1*(F1*f1ton1*(1-l.s)+F1*s11*l.s)+r12*u2*(F2*f2ton1*(1-l.s)+F2*s21*l.s))
c2tof1.new <- r21*u1*(F1*f1ton2*(1-l.s)+F1*s12*l.s)/(r21*u1*(F1*f1ton2*(1-l.s)+F1*s12*l.s)+r22*u2*(F2*f2ton2*(1-l.s)+F2*s22*l.s))
c2tof2.new <- r22*u2*(F2*f2ton2*(1-l.s)+F2*s22*l.s)/(r21*u1*(F1*f1ton2*(1-l.s)+F1*s12*l.s)+r22*u2*(F2*f2ton2*(1-l.s)+F2*s22*l.s))
f1ton1.new <- s11*(a*B1*c1tof1*(1-l.h)+l.h*a*B1*r11)/(s11*(a*B1*c1tof1*(1-l.h)+l.h*a*B1*r11)+s12*(a*B2*c2tof1*(1-l.h)+l.h*a*B2*r21))
f1ton2.new <- s12*(a*B2*c2tof1*(1-l.h)+l.h*a*B2*r21)/(s11*(a*B1*c1tof1*(1-l.h)+l.h*a*B1*r11)+s12*(a*B2*c2tof1*(1-l.h)+l.h*a*B2*r21))
f2ton1.new <- s21*(a*B1*c1tof2*(1-l.h)+l.h*a*B1*r12)/(s21*(a*B1*c1tof2*(1-l.h)+l.h*a*B1*r12)+s22*(a*B2*c2tof2*(1-l.h)+l.h*a*B2*r22))
f2ton2.new <- s22*(a*B2*c2tof2*(1-l.h)+l.h*a*B2*r22)/(s21*(a*B1*c1tof2*(1-l.h)+l.h*a*B1*r12)+s22*(a*B2*c2tof2*(1-l.h)+l.h*a*B2*r22))


if(i == round(0.55*length(tset), 0))
{p1 = 0.75*p2}
if(i == round(0.6*length(tset), 0))
{p1 = p2}


b1.set[i] <- B1 + dB1;n1.set[i] <- N1 + dN1;f1.set[i] <- F1 + dF1
b2.set[i] <- B2 + dB2;n2.set[i] <- N2 + dN2;f2.set[i] <- F2 + dF2;e.set[i] <- E - (dN1 + dN2)
  
c1f1.set[i]<- c1tof1.new;c1f2.set[i]<- c1tof2.new;c2f1.set[i]<- c2tof1.new;c2f2.set[i]<- c2tof2.new
f1n1.set[i]<- f1ton1.new;f1n2.set[i]<- f1ton2.new;f2n1.set[i]<- f2ton1.new;f2n2.set[i]<- f2ton2.new
}

if(j == 1)
{total.2t2f = tibble(time = tset) %>% 
  mutate(b1 = b1.set)%>% 
  mutate(b2 = b2.set)%>% 
  mutate(n1 = n1.set)%>% 
  mutate(n2 = n2.set) %>% 
  mutate(f1 = f1.set)%>% 
  mutate(f2 = f2.set) %>% 
  mutate(roi = 1-l.h) %>% 
  mutate(pref = primary.weight) %>% 
  mutate(resistance= min(b1.set[round(0.55*length(tset),0):length(b1.set)])/b1.set[round(0.55*length(tset),0)]) %>% 
  mutate(resilience = max(tset)*(which(b1.set[round(0.6*length(tset),0):length(b1.set)] > 0.99*b1.set[round(0.55*length(tset),0)-1])[1] )/length(tset))}
if(j>1)
{loop.df = tibble(time = tset) %>% 
  mutate(b1 = b1.set)%>% 
  mutate(b2 = b2.set)%>% 
  mutate(n1 = n1.set)%>% 
  mutate(n2 = n2.set) %>% 
  mutate(f1 = f1.set)%>% 
  mutate(f2 = f2.set)  %>% 
  mutate(roi = 1-l.h) %>% 
  mutate(pref = primary.weight)%>% 
  mutate(resistance= min(b1.set[round(0.55*length(tset),0):length(b1.set)])/b1.set[round(0.55*length(tset),0)]) 
  total.2t2f = total.2t2f %>% 
    bind_rows(loop.df)}
}
long.sanc = total.2t2f %>% 
  pivot_longer(cols = b1:f2, names_to = "pool", values_to = 'size')%>% 
  mutate(pool_short = str_sub(pool, 1,1)) %>% 
  mutate(pref =2*( pref-0.5))



plot.all1 = ggplot(total.2t2f %>% 
         filter(time == max(time)), aes(x = pref, y = roi, fill = resistance))+
         geom_tile()


plot.all2 = ggplot(total.2t2f %>% 
         filter(time == max(time)), aes(x = pref, y = roi, 
                                        fill = b1/b2))+
         geom_tile()

plotall  = plot.all1+plot.all2

ggsave(plot = plotall, filename = here('esa/figures/plotall.png'), width = 10, height = 5)

```
![](figures/plotall.png)


<!-- Done with model description, onwards to analyses -->

## Preference vs. ROI

```{r}
comp_plot = ggplot()+
  geom_blank()+
  lims(x = c(0,1), y = c(0,1))+
  geom_hline(yintercept  = 0.5)+
  geom_vline(xintercept  = 0.5)+
  annotate("text", x = 0.02, y = 0.5, label = "Low Partner\nPreference", size = 4)+
  annotate("text", x = .97, y = 0.5, label = "High Partner\nPreference", size = 4)+
  annotate("text", x = 0.5, y = 0.99, label = "High  ROI", size = 4)+
  annotate("text", x = 0.5, y = 0.01, label = "Low  ROI", size = 4)+
    theme_void()
ggsave(plot = comp_plot, file = here("esa/figures/complot.png"))



```

![](figures/complot.png)

:::{.fragment fragment-index=2}
![](images/investor.jpeg){.absolute top=100 left=0 width="120" height="120"}
:::

:::{.fragment fragment-index=3}
![](images/cheesehead.jpg){.absolute bottom=100 right=50 width="120" height="120"}
:::

:::{.fragment fragment-index=4}
![](images/sandy.jpg){.absolute bottom=100 left=0 width="120" height="120"}
:::


## Discussion
::: columns
::: {.column width="65%"}

<br>

::: {.fragment fragment-index=1}
Connectivity dictates evenness
:::

::: {.fragment fragment-index=2}
<span style="font-size:0.6em;">Both partner preference and ROI</span>
:::

<br>

::: {.fragment fragment-index=3}
Varied environments?
:::

::: {.fragment fragment-index=4}
<span style="font-size:0.6em;">Low connectivity = High resistance, low resilience</span>
:::


:::


::: {.column width="35%"}

![](images/mixedforest.JPG)

:::

:::




## Thank you{background-color="white" background-image="images/title_slide.jpg" background-opacity=0.25} 

::: columns
::: {.column width="15%"}

<br>
<br>
<br>

:::{.fragment fragment-index=2}
![](images/holly.jpg){.absolute top=265 left=0 width="125" height="125"}
:::

<br>

:::{.fragment fragment-index=3}
![](images/hanna.jpg){.absolute top=500 left=0 width="125" height="125"}
:::
:::

::: {.column width="50%"}

<br>

:::{.fragment fragment-index=1}
<span style="font-size:0.8em;">All of you!</span>
:::

<br>

:::{.fragment fragment-index=2}
<span style="font-size:0.8em;">Advisor: Holly Moeller <br> @mixotrophe</span>
:::

<br>
<br>

:::{.fragment fragment-index=3}
<span style="font-size:0.8em;">Artist: Hanna Yang <br> @aytchwye</span>
:::
:::{.fragment fragment-index=3}
![](images/amanitasmall.png){.absolute bottom=-10 left=200 width="35" height="35"}
![](images/suillussmall.png){.absolute bottom=-10 left=240 width="30" height="30"}
![](images/firsmall.png){.absolute bottom=-10 left=150 width="75" height="75"}
![](images/oaksmall.png){.absolute bottom=-15 left=265 width="70" height="70"}
:::
:::

::: {.column width="10%"}

<br>
<br>

![](images/quarto.png)

<br>

![](images/github.png)

:::
::: {.column width="25%"}

<br>
<br>
<br>
<span style="font-size:0.6em;">gaberunte.com/esa2023 </span>

<br>
<br>

<span style="font-size:0.6em;">github.com/gaberunte/myconetwork</span>
:::
:::
# Supplementary materials

